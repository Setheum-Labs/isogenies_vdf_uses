\documentclass{llncs}

\usepackage{amsmath,amsfonts,amssymb}
\usepackage{xcolor}
\usepackage{hyperref}
\hypersetup{
	unicode=true,
	colorlinks=true,
	citecolor=blue!70!black,
	filecolor=black,
	linkcolor=red!70!black,
	urlcolor=blue,
	pdfstartview={FitH},
}

\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\renewcommand{\O}{\mathcal{O}}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\poly}{poly}
\DeclareMathOperator{\polylog}{polylog}
\DeclareMathOperator{\Setup}{\mathsf{Setup}}
\DeclareMathOperator{\TSetup}{\mathsf{TrustedSetup}}
\DeclareMathOperator{\Extract}{\mathsf{Extract}}
\DeclareMathOperator{\Encaps}{\mathsf{Encaps}}
\DeclareMathOperator{\Decaps}{\mathsf{Decaps}}
\newcommand{\pp}{\mathsf{pp}}
\newcommand{\id}{\mathsf{id}}
\newcommand{\idk}{\mathsf{idk}}
\newcommand{\keyspace}{\mathcal{K}}
\newcommand{\cipherspace}{\mathcal{C}}
\newcommand{\Emid}{E_\mathrm{mid}}
\newcommand{\Qmid}{Q_\mathrm{mid}}

\title{Delay Encryption}
\author{Jeffrey Burdges\inst{1}
  \and
  Luca De Feo\inst{2}\orcidID{0000-0002-9321-0773}}
\institute{
  Web 3, Switzerland
  \and
  IBM Research ZÃ¼rich, Switzerland
}

\begin{document}

\maketitle

\begin{abstract}
  We introduce a new primitive named Delay Encryption, and give an
  efficient instantation based on isogenies of supersingular curves
  and pairings. %
  Delay Encryption is related to Time-lock Puzzles and Verifiable
  Delay Functions, and can be roughly described as ``identity based
  encryption with slow decryption''. %
  It has several applications in distributed protocols, such as
  sealed bid Vickrey auctions and...

  We give an instantiation of Delay Encryption by modifying Boneh and
  Frankiln's IBE scheme, where we replace one secret by a long chain
  of isognies, as in the isogeny VDF of De Feo, Masson, Petit and
  Sanso. %
  Similarly to the isogeny-based VDF, our Delay Encryption requires a
  trusted setup before parameters can be safely used; our trusted
  setup is identical to that of the VDF, thus the same parameters can
  be generated once and shared for many executions of both protocols,
  with possibly different delay parameters.

  We also discuss several topics around delay protocols
  based on isogenies that were left untreated by De Feo \emph{et al.},
  namely: distributed trusted setup, watermarking, and implementations
  issues.
\end{abstract}

\section{Introduction}
\label{sec:introduction}

% Recall that an Identity Based Encryption scheme (IBE) is a public
% key encryption

\subsection{Applications of Delay Encryption}


\section{Definitions}
\label{sec:definitions}

Our definition of Delay Encryption uses an API similar to a Key
Encapsulation Mechanism; the adaptation to a PKE-like API is
straightforward. A Delay Encryption scheme consists of four
algorithms: $\Setup$, $\Extract$, $\Encaps$ and $\Decaps$:

\begin{description}
\item[$\Setup(\lambda, T) \to \pp$.] %
  Takes a \emph{security parameter} $\lambda$, a \emph{delay
    parameter} $T$, and produces a set of public parameters $\pp$. %
  $\Setup$ must run in time $\poly(\lambda,T)$.
\item[$\Extract(\pp,\id) \to \idk$.] %
  Takes the public parameters $\pp$ and a \emph{session identifier}
  $\id\in\{0,1\}^*$, and outputs a \emph{session key} $\idk$. %
  $\Extract$ is expected to run in time \emph{exactly} $T$, see below.
\item[$\Encaps(\pp,\id)\to (c,k)$.] %
  Takes the public parameters $\pp$ and a \emph{session identifier}
  $\id\in\{0,1\}^*$, and outputs a \emph{cyphertext}
  $c\in\cipherspace$ and a \emph{key} $k\in\keyspace$. %
  $\Encaps$ must run in time $\poly(\lambda)$.
\item[$\Decaps(\pp,\id,\idk,c)\to k$.] %
  Takes the public parameters $\pp$, a \emph{session identifier}
  $\id$, a \emph{session key} $\idk$, a ciphertext $c\in\cipherspace$,
  and outputs key $k\in\keyspace$. %
  $\Decaps$ must run in time $\poly(\lambda)$.
\end{description}

A Delay Encryption scheme is correct if
\[\bigl(c,\Decaps(\pp,\id,\idk,c)\bigr) = \Encaps(\pp,\id),\]
whenever $\idk=\Extract(\pp,\id)$. %
The security of Delay Encryption is defined similarly to that of
public key encryption schemes, and in particular of identity-based
ones; however one additional property is required of $\Extract$: that
for a randomly selected identifier $\id$, the probability that
$\Extract$ outputs $\idk$ in time less than $T$ is negligible. %
We now give the formal definition.

\paragraph{The security game.} It is apparent from the definitions
that Delay Encryption has no secrets: after public parameters $\pp$
are generated, anyone can run any of the algorithms. %
Thus, the usual notion of indistinguishability will only be defined
with respect to the delay parameter $T$: no adversary is able to
distinguish a key $k$ from a random string in time $T-o(t)$, but
anyone can in time $T$. %
Properly defining what is meant by ``time'' requires fixing a
computation model. %
Here we follow the usual convention from VDFs, and assume a model of
parallel computation: in this context, ``time $T$'' may mean $T$ steps
of a parallel Turing machine, or an arithmetic circuit of depth $T$. %
Crucially, we do not bound the amount of parallelism of the Turing
machine, or the breadth of the circuit, i.e., we focus on
\emph{sequential delay} functions.

We consider the following $\Delta$-IND-CCA game. %
Note that the game involves no oracles, owing to the fact that the
scheme has no secrets. %
%
\begin{description}
\item[Precomputation.] The adversary receives $\pp$ as input, and
  outputs an algorithm $\mathcal{D}$. %
\item[Challenge.] The challenger selects a random $\id$ and computes
  $(c,k_0)\gets\Encaps(\pp,\id)$. %
  It then picks a uniformly random $k_1\in\keyspace$, and a random bit
  $b\in\{0,1\}$. %
  Finally, it outputs $(c,k_b)$.
\item[Guess.] The algorithm $\mathcal{D}$ is run on input
  $(c,k_b)$. %
  The adversary wins if $\mathcal{D}$ terminates in time less than
  $\Delta$, and the output is such that $\mathcal{D}(c,k_b) = b$.
\end{description}

We stress that the game is intrinsically non-adaptive, in the sense
that no computation is ``free'' after the adversary has seen the
challenge.

We say a Delay Encryption scheme is \emph{$\Delta$-Delay
  Indistinguishable under Chosen Ciphertext Attacks} if, for any
efficient adversary running the precomputation in time
$\poly(\lambda,T)$, the probability of winning the game is
negligible. %
Obviously, the interesting schemes are those where $\Delta = T-o(T)$.


\subsection{Isogenies as delay functions}

We instantiate Delay Encryption from the same framework De Feo,
Masson, Petit and Sanso used to instantiate Verifiable Delay
Functions~\cite{10.1007/978-3-030-34578-5_10}. %
We briefly recall it here for completeness.

An elliptic curve $E$ over a finite field $\F_{p^n}$ is said to be
supersingular if the trace of its Frobenius endomorphism is divisible
by $p$, i.e., if $\#E(\F_{p^n})=1\mod p$. %
Over the algebraic closure of $\F_p$, there is only a finite number of
isomorphism classes of supersingular curves, and every class contains
a curve defined over $\F_{p^2}$.

An isogeny is a group morphism of elliptic curves with finite
kernel. %
In particular, isogenies preserve the group order of elliptic curves,
and thus they preserve supersingularity. %
Isogenies can be represented by ratios of polynomials, and, like
polynomials, have a \emph{degree}. %
Isogenies of degree $\ell$ are also called $\ell$-isogenies; the
degree is multiplicative with respect to composition, thus
$\deg\phi\circ\psi=\deg\phi\cdot\deg\psi$. %
The degree is an important invariant of isogenies, roughly measuring
the amount of information needed to represent them.

An isogeny graph is a graph whose vertices are isomorphism classes of
elliptic curves, and whose edges are isogenies, under some
restrictions. %
Isogeny-based cryptography mainly uses two types of isogeny graphs:
\begin{itemize}
\item The \emph{full supersingular graph} of $\F_p$, whose vertices
  are all isomorphism classes of supersingular curves over $\F_{p^2}$,
  and whose edges are all isogenies of a prime degree $\ell$;
  typically $\ell=2,3$.
\item The \emph{$\F_p$-restricted supersingular graph}, or
  \emph{supersingular CM graph} of $\F_p$, whose vertices are all
  $\F_p$-isomorphism classes of supersingular curves over $\F_p$, and
  whose edges are $\ell$-isogenies for all primes $\ell$ up to some
  bound; typically $\ell\lessapprox\lambda\log\lambda$, where
  $\lambda$ is the security parameter.
\end{itemize}

Any $\ell$-isogeny $\phi:E\to E'$ has a unique \emph{dual}
$\ell$-isogeny $\hat\phi:E'\to E$ such that
\begin{equation}
  \label{eq:adjoin}
  e_N(\phi(P),Q) = e_N'(P,\hat\phi(Q)),
\end{equation}
for any integer $N$ and any points $P\in E[N]$, $Q\in E'[N]$, where
$e$ is the Weil pairing on $E$, and $e'$ the one on $E'$. %
The same equation, with the same $\hat\phi$, also holds for any other
known pairing, such as the Tate and Ate pairings.

The framework of De Feo \emph{et al.} uses chains of small degree
isogenies as delay functions, and the pairing
equation~\eqref{eq:adjoin} as an efficient means to verify the
computation. %
Formally, they propose two related instantiations of VDF, following
the same pattern:
%
\begin{description}
\item[Trusted setup] takes as input a security parameter $\lambda$,
  and produces a prime $N\approx 2^{2\lambda}$, a prime $p=N\cdot f+1$
  for some cofactor $f\sim 2^{\lambda^3}$, and a random supersingular
  elliptic curve $E$ over $\F_p$.
\item[Setup] takes as input $p,N,E$, a delay parameter $T$, and
  performs a walk in an $\ell$-isogeny graph to produce a degree
  $\ell^T$ isogeny $\phi:E\to E'$.
  
  It also computes a point $P\in E$ of order $N$, and outputs
  $P,\phi(P)$.
\item[Evaluation] takes as input a random point $Q\in E'[N]$ and outputs
  $\hat\phi(Q)$.
\item[Verification] uses Eq.~\eqref{eq:adjoin} to check that the value
  output by evaluation is $\hat\phi(Q)$ as claimed.
\end{description}

The two variants only differ in the way the isogeny walk is set up,
and in minor details of the verification; these differences will be
irrelevant to us.

The delay property of this VDF rest, roughly speaking, on the
assumption that a chain of $T$ isogenies of small prime degree $\ell$
cannot be computed more efficiently than by going through each of the
isogenies one at a time, sequentially. %
The case $\ell=2$ is very similar to repeated squaring in groups of
unknown order as used by other VDFs~\cite{Wesolowski,Pietrzak} and
time-lock puzzles~\cite{TLP}: in the latter one iterates $T$ times the
function $x\mapsto x^2$, a polynomial of degree $2$; in the former one
iterates rational fractions of degree $2$. %
See Section~\ref{sec:secure-impl-isog} for more details.

It is important to remark that both setup and evaluation in these VDFs
are ``slow'' algorithms, indeed both need to evaluate an isogeny chain
(either $\phi$, or $\hat\phi$) at one input point of order $N$; this
is in stark contrast with VDFs based on groups of unknown order, where
the complexity of setup does not depend on the delay parameter $T$.


\subsection{Instantiation of Delay Encryption}

The isogeny-based VDF of De Feo \emph{et al.}\ can be understood as a
modification on the Boneh--Lynn--Shacham~\cite{boneh+lynn+shacham04}
signature scheme, where the secret key is replaced by a long chain of
isogenies: signing becomes a ``slow'' operation and thus realizes the
evaluation function, whereas verification stays efficient.

Similarly, we obtain a Delay Encryption scheme by modifying the IBE
scheme of Boneh and Franklin~\cite{10.1007/3-540-44647-8_13}: the
master secret is replaced by a long chain of isogenies, while session
identifiers play the role of identities, so that producing the
decryption key for a given identity becomes a slow operation.

Concretely, $\Setup$ is identical to that of the VDF: it is split in a
trusted and an untrusted part, the former being independent of the
delay parameter $T$, and reusable for arbitrarily many untrusted
setups.

\begin{description}
\item[$\TSetup(\lambda)$.]\
  \begin{enumerate}
  \item Generate primes $N$ and $p=4\cdot N\cdot f - 1$, such that
    discrete logarithms in the subgroup of order $N$ of $\F_{p^2}$ are
    $\lambda$-hard;
  \item Generate a nearly uniformly random supersingular curve
    $E/\F_p$ by starting from the curve $y^2=x^3+x$ and performing a
    random walk in the $\F_p$-restricted supersingular graph;
  \item Output $N,p,E$.
  \end{enumerate}
\item[$\Setup(N,p,E,T)$.]\
  \begin{enumerate}
  \item Perform an $\ell$-isogeny walk $\phi:E\to E'$ of length $T$;
  \item Select a random point $P\in E(\F_p)$ of order $N$, and compute
    $\phi(P)$;
  \item Output $E',\phi,P,\phi(P)$.
  \end{enumerate}
\end{description}

The isogeny chain $\phi$ in $\Setup$ can be generated by any of the
two methods proposed by De Feo \emph{et al.}, the difference will be
immaterial for Delay Encryption; as discussed
in~\cite{10.1007/978-3-030-34578-5_10}, a (deterministic) walk limited
to curves and isogenies defined over $\F_p$ will be more efficient,
however a generic (pseudorandom) walk over $\F_{p^2}$ will offer some
partial protection against quantum attacks.

Before defining the other routines, we need two hash functions. %
The first, $H_1:\{0,1\}*\to E'[N]$, will be used to hash session
identifiers to points of order $N$ in $E'/\F_{p^2}$ (although the
curve $E'$ may be defined over $\F_p$). %
The second, $H_2:F_{p^2}\to\{0,1\}^\lambda$, will be a key derivation
function. %
Let $\pp = (N,p,E,E')$, then we define:

\begin{description}
\item[$\Extract(\pp,\phi,\id)$.]\
  \begin{enumerate}
  \item Let $Q = H_1(\id)$;
  \item Output $\hat\phi(Q)$.
  \end{enumerate}
\item[$\Encaps(\pp,P,\phi(P),\id)$.]\
  \begin{enumerate}
  \item Select a uniformly random $r\in\Z/N\Z$;
  \item Let $Q = H_1(\id)$;
  \item Let $k=e_N'(\phi(P),Q)^r$;
  \item Output $(rP,H_2(k))$.
  \end{enumerate}
\item[$\Decaps(\pp,\hat\phi(Q),rP)$.]\
  \begin{enumerate}
  \item Let $k = e_N(rP,\hat\phi(Q))$.
  \item Output $H_2(k)$.
  \end{enumerate}
\end{description}

Correctness of the scheme follows immediately from
Eq.~\eqref{eq:adjoin} and the bilinearity of the pairing. %

\begin{remark}
  Notice that two hashed identities $Q,Q'$ such that
  $Q-Q'\in\langle P\rangle$ are equivalent for encapsulation and
  decapsulation purposes, and thus an adversary only needs to compute
  the image of one of them under $\hat\phi$. %
  However, thanks to $H_1$, the probability of two identities
  collisioning this way is negligible (about $1/N$).
  
  Alternatively, if $E'$ is defined over $\F_p$, one can restrict the
  image of $H_1$ to the subgroup of $E'[N]$ annihilated by $\pi+1$,
  where $\pi$ is the Frobenius endomorphsim, like
  in~\cite{10.1007/978-3-030-34578-5_10}.
\end{remark}


\subsection{Security}

The standard security hypothesis for isogeny-based delay schemes is
the $\Delta$-hardness of the \emph{isogeny shortcut
  game}~\cite{10.1007/978-3-030-34578-5_10}:

\begin{description}
\item[Precomputation.] The adversary receives $N,p,E,E',\phi$, and
  outputs an algorithm $\mathcal{S}$ (in time $\poly(\lambda,T)$).
\item[Challenge.] The challenger outputs a uniformly random
  $Q\in E'[N]$.
\item[Guess.] The algorithm $\mathcal{S}$ is run on input $Q$. The
  adversary wins if $\mathcal{S}$ terminates in time less than
  $\Delta$, and $\mathcal{S}(Q) = \hat\phi(Q)$.
\end{description}

Unfortunately, it seems challenging to reduce $\Delta$-IND-CCA
security of our Delay Encryption scheme to some $\Delta'$-hardness of
an isogeny shortcut game. %
Indeed, even given a more powerful adversary that is able to correctly
compute $k=e_N(rP,\hat\phi(Q))$ in time $\Delta$ from the knowledge or
$Q$ and $rP$, it is not clear how to efficiently extract the value of
$\hat\phi(Q)$ from $k$, as this would amount to efficiently solving a
pairing inversion problem.

It is clear that the isogeny shortcut models a weaker notion of
security for Delay Encryption, one that states that it is hard to
produce the output of $\Extract$ in time less than $\Delta$, however
this is obviously insufficient to guarantee $\Delta'$-IND-CCA, as an
alternative way to compute the key $k$ is to evaluate $\phi(rP)$ and
compute $k=e_N'(\phi(rP), Q)$. %
In practice, computing $\phi(rP)$ is expected to be at least as
``slow'' as computing $\hat\phi(Q)$, however this idea is not captured
by the isogeny shortcut game; and, even then, that would not exclude
other ways to win the $\Delta$-IND-CCA game, without the ability to
extract $\phi(rP)$ or $\hat\phi(Q)$ from a successful adversary.

Replacing the isogeny shortcut game with a decision problem would not
help either, owing to the usual obstacle of decision problems being
easy for pairings; indeed, the decision version of the shortcut game
is easily decided by the verification procedure of the VDF mentioned
above.

Faced with this difficulty, we simply chose to not provide a security
proof, and leave the search for meaningful security reductions for
future work.

\subsubsection{Attacks.} We now shift our attention to attacks. %
As discussed in~\cite{10.1007/978-3-030-34578-5_10}, there are three
types of known attacks: \emph{shortcut} attacks, discrete logarithm
attacks, and attacks on the computation.

Parameters for a Delay Encryption scheme must be chosen so that all
known attacks have exponential difficulty in the security parameter
$\lambda$. %
Given that (total) attacks successfully compute decapsulation in
exponential time in $\lambda$, it is evident that the delay parameter
$T$ must grow at most subexponentially $\lambda$.

\paragraph{Shortcut attacks} aim at computing a shorter path
$\psi:E\to E'$ in the isogeny graph from the knowledge of
$\phi:E\to E'$. %
The name should not be confused with the isogeny shortcut game
described above, as shortcut attacks are only one of the possible ways
to beat the game.

De Feo \emph{et al.}\ show that shortcut attacks are possible when the
endomorphism ring of at least one of $E$ or $E'$ is known. %
Indeed, in this case, the isogeny $\phi$ can be translated to an ideal
class in the endomorphism ring, then smoothing techniques similar
to~\cite{kohel2014quaternion} let us convert the ideal to one of
smaller norm, and finally to an isogeny $\phi:E\to E'$ of smaller
degree.

The only way out of these attacks is to select the starting curve $E$
as a uniformly random supersingular curve over $\F_p$, then no
efficient algorithm is known to compute $\End(E)$, nor $\End(E')$. %
Unfortunately, the only way we currently know to sample nearly
uniformly in the supersingular class over $\F_p$, is to
(paraphrasing) choose the endomorphism ring first, and then compute
$E$ given $\End(E)$.

Thus, the solution put forth in~\cite{10.1007/978-3-030-34578-5_10} is
to generate the starting curve $E$ via a trusted setup, that first
selects $\End(E)$, and then outputs $E$ and throws away the
information about its endomorphism ring. %
We explain in the next section how to mitigate the inconvenience of
having a trusted setup, using a distributed protocol.

As stressed in~\cite{10.1007/978-3-030-34578-5_10}, there is no
evidence that ``hashing'' in the supersingular class, i.e., sampling
nearly uniformly without gaining knowledge of the endomorphism ring,
should be a hard problem. %
But there is no evidence it should be easy either, and several
attempts have failed
already~\cite{cryptoeprint:2019:1202,love2019supersingular}.

Another possibility hinted at in~\cite{10.1007/978-3-030-34578-5_10}
would be to generate ordinary pairing friendly curves with large
isogeny class, as the shortcut attack is then thwarted by the
difficulty of computing the order of the class group of the
endomorphism ring. %
However this possibly seems an even harder problem than hashing to the
supersingular class.

\paragraph{Discrete logarithm attacks} compute $\hat\phi(Q)$ by
directly solving the pairing equation~\eqref{eq:adjoin}. %
In our case, we can even directly attack the key encapsulation. %
Indeed, knowing $rP$, we obtain $r$ through a discrete logarithm, and
then compute $k=e_N'(\phi(P),Q)^r$.

Thanks to the efficiently computable pairing, the discrete logarithm
can actually be solved in $\F_{p^2}$, which motivates taking $p,N$
large enough to resist discrete logarithm computations. %
Obviously, this also shows that our scheme is easily broken by quantum
computers. %
See~\cite{10.1007/978-3-030-34578-5_10}, however, for a discussion of
how a setup with pseudo-random walks over $\F_{p^2}$ resists quantum
attacks in a world where quantum computers are available, but much
more expensive than classical ones.

\paragraph{Attacks on the computation} do not seek to deviate from the
description of the protocol, but simply try to speed up $\Extract$
beyond the way officially prescribed by the scheme. %
In this sort of attacks, the adversary may be given more resources
than the legitimate user: for example, it may be allowed a very large
precomputation, or it may dispose of an unbounded amount of
parallelism, or it may have access to an architecture not available to
the user (e.g., a quantum computer).

These attacks are the most challenging to analyze, because standard
complexity-theoretical techniques are of little help here. %
% (see, however~\cite{todo})
On some level, this goal is unachievable: given a sufficiently
abstract computational model, and a sufficiently powerful adversary,
any scheme is broken. %
For example, an adversary may precompute all possible pairs
$(Q,\hat\phi(Q))$ and store them in a $O(1)$-accessible RAM, then
extraction amounts to a table lookup. %
However, such an adversary with exponential precomputation,
exponential storage, and constant time RAM is easily dismissed as
unreasonable. %
More subtle trade-offs between precomputation, storage and efficiency
can be obtained, like, for example, RNS-based techniques to attack
group-based VDFs~\cite{BernsteinSorenson07}, although the real impact
of these theoretical algorithms has yet to be determined.

Instead, the pragmatical approach taken to address attacks on the
computation, is to massively invest in highly specialized hardware
designs to evaluate the ``slow'' function, and then produce the best
designs at scale, so that they are available to anyone who wants to
run the extraction. %
This is the philosophy of the competitions organized by
Ethereum~\cite{ethereum-vdf} and Chia~\cite{chia-vdf}, targeting,
respectively, the RSA based VDF and the class group based VDF.

We explore this topic more in detail in
Section~\ref{sec:secure-impl-isog}.


\section{Distributed trusted setup}
\label{sec:distr-trust-setup}

Trusted setup is an obvious annoyance to distributed protocols. %
A way to mitigate this negative impact is to distribute trust over
several participants, ensuring through a multi-party computation that,
if at least one participant is honest, then the setup can be trusted.

Ethereum is notoriously investing in the RSA-based VDF with
Wesolowski's proof\cite{ethereum-vdf,Wesolowski}, which is known to
require a trusted setup. %
To generate parameters, the Ethereum network will need to run a
distributed RSA modulus generation, for which all available techniques
essentially trace back to the work of Boneh and
Franklin~\cite{10.1007/BFb0052253}.

Distributed RSA modulus generation is notoriously a difficult task:
the cost is relatively high, and scales badly with the number of
participants. %
Worse still, specialized hardware for the delay function must be
designed specifically for the generated modulus, which means that
little design can be done prior to the distributed generation, and
that if the distributed generation is then found to be rigged, a new
round of distributed-generation-then-design is needed.

On the contrary, distributed parameter generation for our Delay
Encryption candidate, or for the isogeny based VDF, is extremely
easy. %
The participants start from a well known supersingular curve with
known endomorphism ring, e.g., $E_0\,:\,y^2=x^3-x$, and repeat, each
at its own turn, the following steps:
\begin{enumerate}
\item Participant $i$ checks all zero-knowledge proofs published by
  participants that preceded them;
\item They perform a pseudorandom $\psi_i:E_{i-1}\to E_i$
  walk of length $c\log(p)$ in the $\F_p$-restricted supersingular
  graph;
\item They publish $E_i$, and a zero-knowledge proof that they know an
  isogeny $\psi:E_{i-1}\to E_i$.
\end{enumerate}

The constant $c$ is to be determined as a function of the expansion
properties of the isogeny graph, and is meant to be large enough to
ensure nearly uniform mixing of the walk. %
In practice, this constant is usually small, say $c<10$, implying that
each participant needs to evaluate a few thousands isogenies, a
computation that is expected to take in the order of
seconds~\cite{10.1007/978-3-030-03332-3_15}.

The setup is clearly secure as long as at least one participant is
honest: indeed, since each $E_i$ is nearly uniformly distributed,
computing its endomorphism ring is a generic endomorphism ring
computation problem, unless a path to $E_0$ is known.

This distributed computation scales linearly with the number of
participants, each participant needing to check the proofs of the
previous ones. %
It can be left running for a long period of time, allowing many
participants to contribute trust without any need for prior
registration. %
More importantly, it is \emph{updatable}, meaning that after the
distributed generation is complete, the final curve $E$ can be used as
the starting point for a new distributed trusted setup. %
This way the trusted setup can be updated regularly, building upon the
trust accumulated in previous distributed generations.

Compared with the trusted setup for RSA, the outcome of the setup is
much less critical for the design of hardware. %
Indeed, the primes $p,N$ can be publicly chosen in advance, and
hardware can be designed for them before the trusted setup is
performed. %
The trusted curve $E$ only impacts the first few steps of the ``slow''
isogeny walk $\phi:E\to E'$ generated by the untrusted setup, and can
easily be integrated in the hardware design at a later stage

For the zero knowledge proof, several choices are available:
\begin{description}
\item[SIDH-style proofs~\cite{defeo+jao+plut12}] %
  are very inconvenient, because they require primes of a specific
  form, and severely limit the length of pseudo-random walks. %
  On top of that, they are very inefficient. %
  We advise against using them.
\item[SeaSign-style proofs~\cite{10.1007/978-3-030-17659-4_26}] %
  have sizes in the hundred of kilobytes, and their generation and
  verification are extremely slow (dozens of hours). %
  Note that several of the optimizations used for signatures,
  including the class group order precomputation of
  CSI-FiSh~\cite{10.1007/978-3-030-34578-5_9}, are not available in
  this context. %
  More research on the optimization of SeaSign-style proofs for this
  specific context would be welcome.
\item[Generic ZK proofs,] %
  such as SNARKs~\cite{todo} or STARKs~\cite{todo}, are likely to be
  the best candidates at this point. %
  It would be interesting to study which instantiations give the best
  parameters for the problem at hand.
\end{description}

An alternative to ZK-proofs is to use the same tools as for the VDF or
Delay Encryption, i.e., pairings. %
Indeed, Eq.~\eqref{eq:adjoin} can also be seen as a proof of knowledge
of an isogeny pair $(\phi,\hat\phi)$. %
Concretely, a proof of knowledge of an isogeny $\psi_i:E_{i-1}\to E_i$
is instantiated as follows:
\begin{enumerate}
\item Hash the curves $E_{i-1},E_i$ to a pair of points
  $P\in E_{i-1}[(N,\pi-1)]$, $Q\in E_i[(N,\pi+1)]$;
\item Publish $\psi_i(P), \hat\psi_i(Q)$.
\end{enumerate}
Verification would then simply be:
\begin{enumerate}
\item Let $P,Q\gets H(E_{i-1},E_i)$,
\item Check that $\psi_i(P)\in E_i[(N,\pi-1)]$ and
  $\hat\psi_i(Q)\in E_{i-1}[(N,\pi+1)]$;
\item Check that
  $e_N^i(\psi_i(P),Q) = e_N^{i-1}(P,\hat\psi_{i-1}(Q))$.
\end{enumerate}
Remark that while this proves knowledge of an isogeny $E_{i-1}\to E_i$
(under an appropriate computational assumption), it does not prove
anything on its degree.

This proof is compact (it can be reduced to two elements of $\F_p$),
and efficient (computing $\psi_i(P),\hat\psi_i(Q)$ only adds a small
overhead to the computation of $\psi_i$, and verification is
essentially a pairing computation). %
On the flip side, it is not zero-knowledge, thus the security of the
trusted setup stands on a less firm ground.

It would be interesting to find a zero-knowledge proof of knowledge of
an isogeny walk with efficiency comparable to the one sketched above.

\section{Watermarking}
\label{sec:watermarking}

A common requirement in cryptocurrencies is to be able to reward
participants who spend resources to compute the delay function, be it
in the context of a VDF or a Delay Encryption. %
Wesolowski~\cite{Wesolowski} introduced the concept of \emph{proof
  watermarking}, i.e., attaching the proof of a VDF evaluation to an
identity, so that the ownership of the proof cannot be usurped without
performing essentially the same work as evaluating the VDF normally.

In the context of isogeny based VDFs, or of extraction in Delay
Encryption, this is a meaningless concept, because there is simply no
proof to watermark. %
Nevertheless, it is possible to attach a watermark to the output of
the delay function, which gives evidence that the owner of the
watermark spent an amount of effort comparable to legitimately
computing the output. %
The idea is to publish a \emph{mid-point} update on the progress of
the evaluation, and attach this mid-point to the identity of the
evaluator.

Concretely, given parameters $\phi:E\to E'$ and $(P,\phi(P))$, the
isogeny walk is split into two halves of equal size
$\phi_1:E\to \Emid$ and $\phi_2:\Emid\to E'$ so that
$\phi=\phi_2\circ\phi_1$, and $\phi_1(P)$ is . %
Each evaluator then generates a secret key $s\in\Z/N\Z$ and a public
key $s\phi_1(P)$. %
When evaluating $\hat\phi=\hat\phi_1\circ\hat\phi_2$ at a point
$Q\in E'[N]$, the evaluator:
\begin{enumerate}
\item Computes $\Qmid=\hat\phi_2(Q)$,
\item Computes and publishes $s\Qmid$,
\item Finishes off the computation by computing
  $\hat\phi(Q)=\hat\phi_1(\Qmid)$.
\end{enumerate}
A watermark can then be verified by checking that
\[e_N^\mathrm{mid}(\phi_1(P),s\Qmid) = e_N'(s\phi(P),Q).\]
Interestingly, this proof is \emph{blind}, meaning that it can be
verified even before the work is finished.

Given $\hat\phi(Q)$, a usurper wanting to claim the computation for
themselves would need to either start from $Q$ and compute
$\hat\phi_2(Q)$, or start from $\hat\phi(Q)$ and compute
$\frac{\phi_1(\hat\phi(Q))}{\deg\phi_1}$. %
Either way, they would perform at least half as much work as if they
had legitimately evaluated the function.

As described here, it is possible, nevertheless, for a usurper to
target a specific evaluator, by generating a random $u\in\Z/N\Z$, and
choosing $us\phi_1(P)$ as public key. %
Then, any proof $s\Qmid$ for the legitimate evaluator is easily
transformed to a proof $us\Qmid$ for the usurper. %
This attack is easily countered by having all evaluator publish a
zero-knowledge proof of knowledge of their secret exponent $s$, along
with their public key $s\phi_1(P)$. %
Like in the previous section, this proof of knowledge of the secret
exponent can be replaced with an efficient non-zero-knowledge one
using pairings.


\section{Challenges in implementing isogeny-based delay functions}
\label{sec:secure-impl-isog}



\section{Conclusion}

\def\doi#1{\href{https://doi.org/#1}{\tt https://doi.org/\nolinkurl{#1}}}
\bibliography{isovdf,isogenies_bib/isogenies}
\bibliographystyle{splncs04}

\end{document}

% LocalWords:  bilinear instantiation VDF subexponential morphisms
% LocalWords:  instantiations supersingular endomorphism morphism
% LocalWords:  isogenous homomomorphism endomorphisms homomorphism
% LocalWords:  isogenies Frobenius isogeny subgraphs distorsion
% LocalWords:  prover soundess sequentiality quaternion

